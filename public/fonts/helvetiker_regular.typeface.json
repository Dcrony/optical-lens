import * as THREE from "three";
import { useMemo } from "react";

type LensProps = {
  position?: [number, number, number];
  rotation?: [number, number, number];
  rimThickness?: number;
  lensThickness: number;
  baseCurvature: number;
  edgeCurvature: number;
  ior: number;
  width: number;  // Added for adjustability
  height: number; // Added for adjustability
};

export default function Lens({
  position = [0, 0, 0],
  rotation = [0, 0, 0],
  rimThickness = 0.15,
  lensThickness,
  baseCurvature,
  edgeCurvature,
  ior,
  width = 2,
  height = 2
}: LensProps) {
  const { lensGeometry, rimGeometry } = useMemo(() => {
    const w = width;
    const h = height;
    const r = 0.45; // Corner radius

    /* ---------- Adjustable Shape ---------- */
    const shape = new THREE.Shape();
    shape.moveTo(0, h / 2);
    // Top Edge with Cat-Eye flick logic
    shape.bezierCurveTo(w * 0.2, h / 2, w / 2, h / 2, w / 2, h / 2 - r);
    // Outer side
    shape.bezierCurveTo(w / 2 + r * 0.2, h / 2 - r * 2, w / 2, -h / 2 + r, w / 2, -h / 2);
    // Bottom
    shape.bezierCurveTo(w * 0.2, -h / 2, -w * 0.2, -h / 2, -w / 2, -h / 2);
    // Inner side
    shape.bezierCurveTo(-w / 2, -h / 2 + r, -w / 2 - r * 0.2, h / 2 - r * 2, -w / 2, h / 2 - r);
    // Close shape
    shape.bezierCurveTo(-w / 2, h / 2, -w * 0.2, h / 2, 0, h / 2);

    /* ---------- Curvature Logic ---------- */
    const applyCurvature = (geo: THREE.ExtrudeGeometry, thick: number) => {
      const pos = geo.attributes.position;
      const centerZ = thick / 2;
      for (let i = 0; i < pos.count; i++) {
        const x = pos.getX(i);
        const y = pos.getY(i);
        const z = pos.getZ(i);
        const nx = x / (w / 2);
        const ny = y / (h / 2);
        const dist = Math.min(1, Math.sqrt(nx * nx + ny * ny));
        
        const curve = (dist * dist) * baseCurvature + (dist * edgeCurvature * 0.5);
        
        // Front is pushed forward, back is pushed forward (concave)
        pos.setZ(i, z > 0 ? z + curve : z + curve - thick);
      }
    };

    const lensGeo = new THREE.ExtrudeGeometry(shape, {
      depth: lensThickness,
      bevelEnabled: true,
      bevelThickness: 0.05, // V-Bevel
      bevelSize: 0.02,
      curveSegments: 64,
    });
    
    applyCurvature(lensGeo, lensThickness);
    lensGeo.computeVertexNormals();
    lensGeo.center();

    const rimGeo = new THREE.ExtrudeGeometry(shape, {
      depth: rimThickness,
      bevelEnabled: false,
      curveSegments: 64,
    });
    rimGeo.center();

    return { lensGeometry: lensGeo, rimGeometry: rimGeo };
  }, [lensThickness, baseCurvature, edgeCurvature, rimThickness, width, height]);

  return (
    <group position={position} rotation={rotation}>
      {/* Lens Frame / Rim */}
      <mesh geometry={rimGeometry}>
        <meshStandardMaterial color="#111827" metalness={0.8} roughness={0.2} side={THREE.DoubleSide} />
      </mesh>

      {/* Clear Optical Lens */}
      <mesh geometry={lensGeometry}>
        <meshPhysicalMaterial
          color="#ffffff"
          transmission={1.0} // Fully clear
          thickness={lensThickness}
          roughness={0.0}
          ior={ior}
          transparent
          opacity={0.3} // High transparency
          clearcoat={1}
          attenuationColor="#ffffff"
          attenuationDistance={1}
          side={THREE.DoubleSide}
        />
      </mesh>
    </group>
  );
}